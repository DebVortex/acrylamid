Commands
========

Unlike other popular static blog compiler Acrylamid uses a CLI interface that
uses positional arguments for each task. Long options are used for special
flags like force or dry run. The basic call is ``acrylamid <subcommand>
[options] [args]``.

-q, --quiet     less verbose
-v, --verbose   more verbose
-C, --no-color  disable color
-h, --help      show this help message and exit
--version       print version details


init
----

This initializes the base structure of an Acrylamid blog, thus it should be
the first command you'll execute. In addition to initialization it also can
restore changed/deleted files if you specify the complete path as argument.

-f, --force       don't ask, just overwrite
--html5           use HTML5 layout (default)
--xhtml           use legacy XHTML 1.1 layout

::

    $> acrylamid init foo
         create  foo/conf.py
         ...
         create  foo/layouts/rss.xml
         create  foo/output/blog.css
    Created your fresh new blog at 'foo'. Enjoy!

If you give . (dot) as argument the current working dir is used. Let's say you
have edited *output/blog.css* and want restore the original version.

::

    $> cd foo/
    $> $> acrylamid init output/blog.css
    re-initialize 'output/blog.css'? [yn]: y
      re-initialized output/blog.css


new
---

With ``acrylamid new`` you specify a title in [args] or you'll get prompted to
enter a title and Acrylamid automatically create the post using the current
datetime and places the file into ``CONTENT_DIR`` (defaults to content/) using
``PERMALINK_FORMAT`` as path expansion. Afterwards it'll launch your
favourite $EDITOR.

::

    $> acrylamid new
    Entry's title: This rocks!
         create  content/2012/this-rocks.txt
         [opens TextMate for me]


compile
-------

Compiles all your content using global, view and entry filters with some magic
and generates all files into ``OUTPUT_DIR`` (defaults to output/). Note that
this command will *not* remove orphaned files. Depending on your changes and
content size it may take some time.

-f, --force     clear cache before compilation
-i, --ignore    ignore critical errors (e.g. missing module in a filters)
-n, --dry-run   show what would have been compiled

::

    $> acrylamid compile
           skip  output/articles/index.html
           skip  output/2012/foo/index.html
         update  [0.31s] output/2012/this-rocks/index.html
           skip  output/2011/die-verwandlung/index.html
         update  [0.01s] output/rss/index.html
         update  [0.01s] output/atom/index.html
         update  [0.00s] output/index.html
           skip  output/tag/die-verwandlung/index.html
           skip  output/tag/franz-kafka/index.html
    Blog compiled in 0.43s


view
----

After you compiled your blog you could ``cd output/ && python -m
SimpleHTTPServer`` to view the output, but this is rather exhausting. Its much
simpler to run ``acrylamid view`` and it automatically serves on port 8000.
Hit *Ctrl-C* to exit.

-p PORT, --port=PORT  webserver port

::

    $> acrylamid view -p 1234
     * Running on http://127.0.0.1:1234/


autocompile
-----------

If you need visual feedback while you write an entry, Acrylamid can
automatically compile and serve when you save your document. Hit *Ctrl-C* to
quit.

-f, --force           clear cache before compilation
-i, --ignore    ignore critical errors (e.g. missing module in a filters)
-p PORT, --port=PORT  webserver port

::

    $> acrylamid aco
     * Running on http://127.0.0.1:8000/
    Blog compiled in 0.12s
     * [echo 1 >> content/sample-entry.txt]
         update  [0.32s] output/2011/die-verwandlung/index.html
         update  [0.02s] output/rss/index.html
         update  [0.01s] output/atom/index.html
    Blog compiled in 0.40s


clean
-----

With the time Acrylamid compiles some files you later renamed or just removed.
These files are not touched until you force it with ``acrylamid clean``. This
actually run a ``acrylamid compile -q`` and tracks all visited files thus
afterwards it can show and delete untracked files in ``OUTPUT_DIR``.

If you have static files in ``OUTPUT_DIR`` you should add them to
``OUTPUT_IGNORE`` which defaults to ``['style.css', 'img/*', 'images/*']`` --
otherwise Acrylamid removes them.

-f, --force     remove all files generated by Acrylamid
-n, --dry-run   show what would have been deleted

::

    $> rm content/2012/foo.txt
    $> acrylamid clean
        removed  output/2012/foo/index.html

The syntax for patterns in ``OUTPUT_IGNORE`` is similar to ``git-ignore``: a
path with a leading slash means absolute position (to /path/to/output/),
path with trailing slash marks a directory and everything else is just
relative fnmatch.

- ``".hidden"`` matches every file named *.hidden*, ``"/.hidden"`` matches
  a file in the base directory named the same.
- ``".git/*"`` excludes *HEAD*, *config* and *description* but not the
  directories  *hooks/* and *info/*.
- ``".git/"`` ignores a *.git* folder anywhere in the output directory,
  ``"/.git/"`` only *output/.git*.

If you are unsure, wether your pattern works, use -n/--dry-run!


import
------

Acrylamid features a basic RSS, Atom feed importer and also a WordPress Export
importer to make it more easy to move to Acrylamid. To import a feed, point to
an URL or local FILE. By default, all HTML is reconversed to Markdown using,
first pandoc_ if found, then `html2text
<http://www.aaronsw.com/2002/html2text/>`_ if found, else the plain HTML is
stored into plaintext files. reStructuredText is also supported by pandoc_ and
optional by `html2rest <http://pypi.python.org/pypi/html2rest>`_. If you have
imported your content successfully you get a short hint of what configuration
you have to edit to.

Migrating from WordPress is more difficult than an RSS/Atom feed because WP does
not store a valid HTML content but a pre-HTML state. Thus we fix this with some
stupid <br />-Tags to convert it back to Markdown/reStructuredText. It is not
recommended to import WordPress blogs as pure HTML because it does not validate!

.. _pandoc: http://johnmacfarlane.net/pandoc/

::

    $> acrylamid init foo  # we need a base structure before we import

    $> acrylamid import http://example.com/rss/
         create  content/2012/entry.txt
         create  content/2012/another-entry.txt
         ...
    $> acrylamid import -k example.wordpress.xml
         create  content/dan/wordpress/2008/08/a-simple-post-with-text.txt
         create  content/dan/wordpress/news/our-company.txt
         ...

.. note::

    If you get a *critical  Entry already exists u'content/2012/update.txt'*,
    you may change your ``PERMALINK_FORMAT`` to a more fine-grained
    ``"/:year/:month/:day/:slug/index.html"`` import strategy. If you don't
    which a re-layout of your entries, you can use ``--keep-links`` to use the
    permalink as path.

-m, --markup=LANG   reconversion of HTML to LANG, supports every language that
                    pandoc supports (if you have pandoc installed). Use "HTML"
                    if you don't whish any reconversion.
-k, --keep-links    keep original permanent-links and also create content
                    structure in that way. This does *not* work, if you links
                    are like this: ``/?p=23``.


deploy
------

With ``acrylamid deploy TASK`` you can run single commands, e.g. push just
generated content to your server. Write new tasks into the DEPLOYMENT dict
inside your ``conf.py`` like this:

::

    DEPLOYMENT = {
        "ls": "ls",
        "echo": "echo %s",
        "blog": "rsync -av --delete %s www@server:~/blog.example.org/"
    }

Now, you can invoke *ls*, *echo* and *blog* as TASK. This example config shows
you all possibilities to create a scripts. A plain ``ls`` is internally
extended to ``ls %s`` where ``%s`` is substituted with the current
``OUTPUT_DIR``-variable as you can see in the second task). The third task is
simple command to deploy your blog directly to your server -- notice the
substitution variable can be anywhere.

::

    $> acrylamid deploy ls
        2009
        2010
        ...
        tag

    $> acrylamid deploy echo
        output/

    $> acrylamid deploy blog
        building file list ... done

        sent 19701 bytes  received 20 bytes  7888.40 bytes/sec
        total size is 13017005  speedup is 660.06

It's also possible to pass additional commands to these tasks. Every argument
after the task identifier is passed to and using ``--`` as delimiter for
acrylamid's flags you can also apply opts and long-opts:

::

    $> acrylamid deploy ls -- content/ -d
        content/
        output/
